# Section 2

## Task 6 — Simple List (SnackBar)
This screen uses `ListView.builder` to efficiently render 10 items without prebuilding the entire list, which keeps memory usage low and performance predictable. Each item is a `ListTile` with basic spacing and a bold title for readability, meeting the styling requirement. Because the list doesn’t change after creation, I used a `StatelessWidget`. The `onTap` callback triggers a `SnackBar` via `ScaffoldMessenger.of(context)`, which is the recommended approach for transient feedback. If the list grows, the builder pattern remains scalable and continues to reuse rows during scrolling. The code is minimal and clear, making it easy to test or extend with icons, navigation, or long-press actions while still satisfying the task’s interactive behavior and styling constraints.

## Task 7 — Login Form (Validation)
The form uses a `GlobalKey<FormState>` to coordinate validation across two fields. The email validator checks for emptiness and a simple format (`@` and `.`) to satisfy the requirement without heavy regex. The password validator enforces a configurable minimum length, which changing `_minPasswordLength` from 6 to 8 adapts the rule instantly for a live session. `AutovalidateMode.onUserInteraction` gives users timely, helpful feedback as they type. On submit, `_formKey.currentState?.validate()` runs all validators; if valid, the app shows a `SnackBar` saying “Form Submitted.” Controllers are used to enable enhancements (e.g., trimming, toggling visibility) without touching validation logic. The widget is `Stateful` because validation messages and button state can change during interaction.

## Task 8 — Users API (Loading + Error)
This implementation separates concerns into a `User` model, an `ApiService.fetchUsers()` function, and a `UsersScreen` widget. The HTTP call uses `http.get` and decodes JSON into typed `User` objects, throwing an exception if the response is non‑200 so errors are explicit. In the UI, `FutureBuilder` handles the three essential states: loading (spinner), error (clear message), and success (list). An explicit empty state avoids ambiguous blank screens. `ListView.separated` adds lightweight dividers to keep the list readable. This pattern is idiomatic for a one‑shot fetch without heavier state management. It’s easy to extend (retry, pull‑to‑refresh, caching) and straightforward to demonstrate in a live session while explaining HTTP status handling and JSON parsing.
